<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WW1 Air Patrol</title>

  <!-- iPhone full-screen web app settings -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="FokkerDR3.png">

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #aee1ff 0, #4d7fbf 60%, #1e2a3a 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #f5f5f5;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    .game-wrapper {
      position: relative;
      padding: 16px;
      border-radius: 18px;
      background: rgba(0, 0, 0, 0.25);
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(6px);
    }

    canvas {
      display: block;
      background: #6bb34d;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    }

    .hud {
      position: absolute;
      top: 20px;
      left: 24px;
      display: flex;
      gap: 18px;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
      font-size: 14px;
      pointer-events: none;
    }

    .hud span.label {
      opacity: 0.8;
      font-weight: 400;
      margin-right: 4px;
    }

    #lives {
      color: #ff6666;
      font-size: 16px;
      letter-spacing: 2px;
    }

    .hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      opacity: 0.9;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.7);
      text-align: center;
      pointer-events: none;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <canvas id="game" width="480" height="640"></canvas>

    <div class="hud">
      <div><span class="label">Score:</span><span id="score">0</span></div>
      <div><span class="label">Best:</span><span id="best">0</span></div>
      <div><span class="label">Stage:</span><span id="levelName">Fokker Eindecker</span></div>
      <div><span class="label">Lives:</span><span id="lives">❤❤❤</span></div>
    </div>

    <div class="hint" id="hint">
      Tap a side to enter
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    /** @type {CanvasRenderingContext2D} */
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");
    const hintEl = document.getElementById("hint");
    const levelNameEl = document.getElementById("levelName");
    const livesEl = document.getElementById("lives");

    const W = canvas.width;
    const H = canvas.height;
    const GROUND_HEIGHT = 90;

    const UI_FONT = "Segoe UI, Tahoma, Geneva, Verdana, sans-serif";

    // --- Screens ---
    // "splash" → choose side (German / British)
    // "planeSelectGerman" → list of tiers
    // "planeSelectBritish" → under construction
    // "game" → actual flying
    let screen = "splash";

    // clickable areas
    let germanEntryRect = null;
    let britishEntryRect = null;
    let germanPlaneChoices = [];

    function fillRoundedRect(x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
    }

    // === Load sprites ===
    const dr3Img = new Image();
    let dr3Loaded = false;
    dr3Img.onload = () => { dr3Loaded = true; };
    dr3Img.onerror = () => console.error("Could not load FokkerDR3.png");
    dr3Img.src = "FokkerDR3.png";

    const dr1Img = new Image();
    let dr1Loaded = false;
    dr1Img.onload = () => { dr1Loaded = true; };
    dr1Img.onerror = () => console.error("Could not load FokkerDR1.png");
    dr1Img.src = "FokkerDR1.png";

    const balloonImg = new Image();
    let balloonLoaded = false;
    balloonImg.onload = () => { balloonLoaded = true; };
    balloonImg.onerror = () => console.error("Could not load ObsBaloon.png");
    balloonImg.src = "ObsBaloon.png";

    const zeppelinImg = new Image();
    let zeppelinLoaded = false;
    zeppelinImg.onload = () => { zeppelinLoaded = true; };
    zeppelinImg.onerror = () => console.error("Could not load Zeppelin.png");
    zeppelinImg.src = "Zeppelin.png";

    const diegoImg = new Image();
    let diegoLoaded = false;
    diegoImg.onload = () => { diegoLoaded = true; };
    diegoImg.onerror = () => console.error("Could not load DiegoPilot.png");
    diegoImg.src = "DiegoPilot.png";

    // Splash logo
    const splashLogo = new Image();
    let splashLogoLoaded = false;
    splashLogo.onload = () => { splashLogoLoaded = true; drawSplash(); };
    splashLogo.onerror = () => console.error("Could not load Logo.png");
    splashLogo.src = "Logo.png";

    // Levels (WW1 themed)
    const LEVELS = [
      {
        name: "Fokker Eindecker",
        obstacle: "cloud",
        speed: 2.4,
        spawnInterval: 1400,
        gravity: 0.28,
        jump: -6.5,
        sky: ["#cbdaf0", "#f2f5fb"],
        ground: ["#c9b884", "#9f8957"]
      },
      {
        name: "Observation Balloons",
        obstacle: "balloon",
        speed: 2.8,
        spawnInterval: 1200,
        gravity: 0.32,
        jump: -7.0,
        sky: ["#e3e3e3", "#cfcfcf"],
        ground: ["#b2c18a", "#7a9153"]
      },
      {
        name: "Zeppelin Raid",
        obstacle: "zeppelin",
        speed: 3.0,
        spawnInterval: 1150,
        gravity: 0.33,
        jump: -7.2,
        sky: ["#9aa7c3", "#d8dde7"],
        ground: ["#8c8b6a", "#494736"]
      },
      {
        name: "Ace of Aces",
        obstacle: "flak",
        speed: 3.4,
        spawnInterval: 1000,
        gravity: 0.35,
        jump: -7.4,
        sky: ["#5b7b9a", "#cfd7e0"],
        ground: ["#5c6b40", "#2f3a20"]
      }
    ];

    const PLANE_WIDTH = 52;
    const PLANE_HEIGHT = 28;
    const PLANE_X = 90;

    let currentLevelIndex = 0;

    let plane;
    let obstacles;
    let score = 0;
    let bestScore = parseInt(localStorage.getItem("ww1_fokker_best") || "0", 10);
    let dr1Unlocked = localStorage.getItem("dr1_unlocked") === "1";

    let lives = 3;
    let damageLevel = 0;

    let gameRunning = false;
    let gameOver = false;
    let lastTime = 0;
    let lastSpawnTime = 0;

    const parallax = { far: 0, mid: 0, fore: 0 };

    // which plane is selected for the game
    let planeType = "dr3"; // "dr3", "dr1", "diego"

    scoreEl.textContent = score;
    bestEl.textContent = bestScore;
    levelNameEl.textContent = LEVELS[currentLevelIndex].name;

    function updateLivesDisplay() {
      let hearts = "";
      for (let i = 0; i < lives; i++) hearts += "❤";
      livesEl.textContent = hearts;
    }

    updateLivesDisplay();

    function resetGame() {
      plane = {
        x: PLANE_X,
        y: H / 2,
        width: PLANE_WIDTH,
        height: PLANE_HEIGHT,
        vy: 0,
        invincibleUntil: 0
      };
      obstacles = [];
      score = 0;
      lives = 3;
      damageLevel = 0;
      scoreEl.textContent = score;
      updateLivesDisplay();
      lastTime = 0;
      lastSpawnTime = 0;
      gameOver = false;
      gameRunning = false;
      currentLevelIndex = 0;
      levelNameEl.textContent = LEVELS[currentLevelIndex].name;
      parallax.far = 0;
      parallax.mid = 0;
      parallax.fore = 0;
    }

    function startGameLoop() {
      if (!gameRunning && !gameOver) {
        gameRunning = true;
        requestAnimationFrame(loop);
      }
    }

    function flap() {
      const level = LEVELS[currentLevelIndex];
      plane.vy = level.jump;
    }

    function updateLevelByScore() {
      let newIndex = 0;
      if (score >= 30) newIndex = 3;
      else if (score >= 20) newIndex = 2;
      else if (score >= 10) newIndex = 1;
      else newIndex = 0;

      if (newIndex !== currentLevelIndex) {
        currentLevelIndex = newIndex;
        levelNameEl.textContent = LEVELS[currentLevelIndex].name;
      }
    }

    function checkUnlocks() {
      if (!dr1Unlocked && currentLevelIndex === 3 && score >= 40) {
        dr1Unlocked = true;
        localStorage.setItem("dr1_unlocked", "1");
        hintEl.textContent = "Fokker DR.1 unlocked! Use German → Tier 2 to select it.";
      }
    }

    // Spawn obstacles, with flak mixing at high scores
    function spawnObstacle(timestamp) {
      const level = LEVELS[currentLevelIndex];
      if (!lastSpawnTime) lastSpawnTime = timestamp;
      if (timestamp - lastSpawnTime < level.spawnInterval) return;

      lastSpawnTime = timestamp;

      const marginTop = 80;
      const marginBottom = 80;
      const yMin = marginTop;
      const yMax = H - GROUND_HEIGHT - marginBottom;
      const baseY = Math.random() * (yMax - yMin) + yMin;

      // Default obstacle type from level
      let obstacleType = level.obstacle;

      // In "Ace of Aces" (flak stage) mix in other types at higher scores
      if (currentLevelIndex === 3) {
        if (score >= 500) {
          // flak + zeppelins
          const r = Math.random();
          obstacleType = (r < 0.6) ? "flak" : "zeppelin";
        } else if (score >= 400) {
          // flak + balloons
          const r = Math.random();
          obstacleType = (r < 0.6) ? "flak" : "balloon";
        } else if (score >= 300) {
          // flak + clouds
          const r = Math.random();
          obstacleType = (r < 0.7) ? "flak" : "cloud";
        } else {
          obstacleType = "flak";
        }
      }

      const radius = obstacleType === "zeppelin" ? 40 : 26;

      obstacles.push({
        x: W + radius + 10,
        y: baseY,
        baseY,
        r: radius,
        type: obstacleType,
        scored: false,
        phase: Math.random() * Math.PI * 2
      });
    }

    function registerHit(timestamp) {
      if (plane.invincibleUntil && timestamp < plane.invincibleUntil) {
        return false;
      }

      plane.invincibleUntil = timestamp + 900;
      damageLevel++;
      lives = Math.max(0, lives - 1);
      updateLivesDisplay();

      if (damageLevel >= 3 || lives <= 0) {
        damageLevel = 3;
        endGame();
        return true;
      }
      return false;
    }

    function update(dt, timestamp) {
      const level = LEVELS[currentLevelIndex];
      // Base speed for this level
      let levelSpeed = level.speed;

      // EXTRA: after 150 points in flak stage, gradually speed up every 50 points
      if (currentLevelIndex === 3 && score >= 150) {
        const extraSteps = Math.floor((score - 150) / 50) + 1; // 150–199 → 1, 200–249 → 2, etc.
        const extra = extraSteps * 0.25; // tweak value for how strong the speed-up is
        levelSpeed += extra;
      }

      const speedFactor = dt / (1000 / 60);

      plane.vy += level.gravity * speedFactor;
      plane.y += plane.vy * speedFactor;

      spawnObstacle(timestamp);

      for (const o of obstacles) {
        // use adjusted speed for obstacle movement
        o.x -= levelSpeed * speedFactor;

        let amp = 0;
        let freq = 0;
        if (o.type === "balloon") {
          amp = 10;
          freq = 0.003;
        } else if (o.type === "zeppelin") {
          amp = 6;
          freq = 0.002;
        }
        if (amp > 0) {
          o.y = o.baseY + Math.sin(timestamp * freq + o.phase) * amp;
        }
      }

      obstacles = obstacles.filter(o => o.x + o.r > -20);

      // parallax movement also uses adjusted levelSpeed
      const base = levelSpeed * speedFactor;
      parallax.far -= base * 0.3;
      parallax.mid -= base * 0.6;
      parallax.fore -= base * 1.0;

      if (plane.y < 0 || plane.y + plane.height > H - GROUND_HEIGHT) {
        damageLevel = 3;
        lives = 0;
        updateLivesDisplay();
        endGame();
        return;
      }

      const planeCx = plane.x + plane.width / 2;
      const planeCy = plane.y + plane.height / 2;
      let planeFactor = 0.6;
      if (planeType === "dr1") planeFactor = 0.7;
      if (planeType === "diego") planeFactor = 0.55;
      const planeR = Math.min(plane.width, plane.height) * planeFactor;

      for (const o of obstacles) {
        const dx = planeCx - o.x;
        const dy = planeCy - o.y;
        const distSq = dx * dx + dy * dy;
        const rad = planeR + o.r + 3;
        if (distSq < rad * rad) {
          const gameEnded = registerHit(timestamp);
          if (gameEnded) return;
          plane.vy = -3;
        }

        if (!o.scored && o.x + o.r < plane.x) {
          o.scored = true;
          score++;
          scoreEl.textContent = score;
          if (score > bestScore) {
            bestScore = score;
            bestEl.textContent = bestScore;
            localStorage.setItem("ww1_fokker_best", String(bestScore));
          }
          updateLevelByScore();
          checkUnlocks();
        }
      }
    }

    // --- Background & parallax ---
    function drawBackground() {
      const level = LEVELS[currentLevelIndex];

      ctx.clearRect(0, 0, W, H);

      const skyGradient = ctx.createLinearGradient(0, 0, 0, H - GROUND_HEIGHT);
      skyGradient.addColorStop(0, level.sky[0]);
      skyGradient.addColorStop(1, level.sky[1]);
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, W, H - GROUND_HEIGHT);

      ctx.fillStyle = "rgba(255,255,255,0.7)";
      drawCloudShape(80, 90, 22);
      drawCloudShape(180, 60, 18);
      drawCloudShape(340, 110, 26);

      const groundGradient = ctx.createLinearGradient(0, H - GROUND_HEIGHT, 0, H);
      groundGradient.addColorStop(0, level.ground[0]);
      groundGradient.addColorStop(1, level.ground[1]);
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, H - GROUND_HEIGHT, W, GROUND_HEIGHT);

      drawParallaxGround();
    }

    function drawParallaxGround() {
      const groundTop = H - GROUND_HEIGHT;
      const farY = groundTop + 16;
      const midY = groundTop + 30;
      const foreY = groundTop + 40;

      const farSegW = 140;
      let fx = parallax.far % farSegW;
      if (fx > 0) fx -= farSegW;

      ctx.fillStyle = "#3e5136";
      for (let x = fx; x < W + farSegW; x += farSegW) {
        ctx.beginPath();
        ctx.moveTo(x, H);
        ctx.lineTo(x, farY + 18);
        ctx.quadraticCurveTo(
          x + farSegW * 0.25, farY - 6,
          x + farSegW * 0.5, farY + 10
        );
        ctx.quadraticCurveTo(
          x + farSegW * 0.75, farY + 24,
          x + farSegW, farY + 12
        );
        ctx.lineTo(x + farSegW, H);
        ctx.closePath();
        ctx.fill();
      }

      const midSegW = 110;
      let mx = parallax.mid % midSegW;
      if (mx > 0) mx -= midSegW;

      for (let x = mx; x < W + midSegW; x += midSegW) {
        ctx.fillStyle = "#7e653e";
        ctx.fillRect(x, midY + 4, midSegW * 0.7, 8);

        ctx.fillStyle = "#5b4a30";
        ctx.beginPath();
        ctx.ellipse(x + midSegW * 0.35, midY + 10, 10, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(40,30,20,0.9)";
        ctx.lineWidth = 1.3;
        ctx.beginPath();
        ctx.moveTo(x + 6, midY);
        ctx.lineTo(x + 6, midY - 8);
        ctx.moveTo(x + 26, midY);
        ctx.lineTo(x + 26, midY - 7);
        ctx.stroke();

        ctx.strokeStyle = "rgba(80,60,40,0.8)";
        ctx.lineWidth = 0.9;
        ctx.beginPath();
        ctx.moveTo(x + 6, midY - 7);
        ctx.lineTo(x + 26, midY - 6);
        ctx.stroke();
      }

      const foreSegW = 130;
      let bx = parallax.fore % foreSegW;
      if (bx > 0) bx -= foreSegW;

      for (let x = bx; x < W + foreSegW; x += foreSegW) {
        ctx.fillStyle = "#4a3b26";
        ctx.beginPath();
        ctx.moveTo(x, foreY + 10);
        ctx.lineTo(x + 18, foreY + 4);
        ctx.lineTo(x + 40, foreY + 12);
        ctx.lineTo(x + 68, foreY + 6);
        ctx.lineTo(x + 92, foreY + 14);
        ctx.lineTo(x + foreSegW, foreY + 8);
        ctx.lineTo(x + foreSegW, H);
        ctx.lineTo(x, H);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#34312c";
        const bunkX = x + 24;
        const bunkY = foreY - 6;
        ctx.fillRect(bunkX, bunkY, 32, 16);

        ctx.fillStyle = "#1b1a18";
        ctx.fillRect(bunkX + 8, bunkY + 7, 18, 7);

        const smokeBaseX = bunkX + 26;
        const smokeBaseY = bunkY - 4;
        ctx.fillStyle = "rgba(90,90,90,0.6)";
        ctx.beginPath();
        ctx.arc(smokeBaseX, smokeBaseY, 6, 0, Math.PI * 2);
        ctx.arc(smokeBaseX + 6, smokeBaseY - 6, 5, 0, Math.PI * 2);
        ctx.arc(smokeBaseX - 4, smokeBaseY - 10, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawCloudShape(cx, cy, r) {
      ctx.beginPath();
      ctx.arc(cx - r, cy, r, Math.PI * 0.5, Math.PI * 1.5);
      ctx.arc(cx, cy - r, r, Math.PI, 0);
      ctx.arc(cx + r, cy, r, Math.PI * 1.5, Math.PI * 0.5);
      ctx.closePath();
      ctx.fill();
    }

    // --- Star + flak cloud ---
    function drawStar6(cx, cy, outerR, innerR, color, alpha) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;

      ctx.beginPath();
      const spikes = 6;
      const step = Math.PI / spikes;
      let rot = -Math.PI / 2;

      for (let i = 0; i < spikes * 2; i++) {
        const r = (i % 2 === 0) ? outerR : innerR;
        const x = cx + Math.cos(rot) * r;
        const y = cy + Math.sin(rot) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
        rot += step;
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawFlakCloud(cx, cy, baseR) {
      const R = baseR * 1.3;

      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = "rgb(40,40,40)";

      ctx.beginPath();
      ctx.arc(cx, cy, R * 0.8, 0, Math.PI * 2);
      ctx.arc(cx - R * 0.6, cy, R * 0.75, 0, Math.PI * 2);
      ctx.arc(cx + R * 0.6, cy, R * 0.75, 0, Math.PI * 2);
      ctx.arc(cx, cy - R * 0.6, R * 0.7, 0, Math.PI * 2);
      ctx.arc(cx, cy + R * 0.6, R * 0.7, 0, Math.PI * 2);
      ctx.arc(cx - R * 0.45, cy - R * 0.45, R * 0.65, 0, Math.PI * 2);
      ctx.arc(cx + R * 0.45, cy + R * 0.45, R * 0.65, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawObstacle(o) {
      if (o.type === "cloud") {
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        drawCloudShape(o.x, o.y, o.r);
      } else if (o.type === "balloon") {
        if (balloonLoaded) {
          const scale = 0.45;
          const imgW = balloonImg.width * scale;
          const imgH = balloonImg.height * scale;
          ctx.drawImage(
            balloonImg,
            o.x - imgW / 2,
            o.y - imgH / 2,
            imgW,
            imgH
          );
        } else {
          ctx.fillStyle = "#e0c68b";
          ctx.beginPath();
          ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
          ctx.fill();
        }
      } else if (o.type === "zeppelin") {
        if (zeppelinLoaded) {
          const scale = 0.45;
          const imgW = zeppelinImg.width * scale;
          const imgH = zeppelinImg.height * scale;
          ctx.drawImage(
            zeppelinImg,
            o.x - imgW / 2,
            o.y - imgH / 2,
            imgW,
            imgH
          );
        } else {
          ctx.fillStyle = "#c6b38c";
          ctx.beginPath();
          ctx.ellipse(o.x, o.y, o.r * 1.7, o.r, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      } else if (o.type === "flak") {
        const baseR = o.r;
        drawFlakCloud(o.x, o.y, baseR);

        const cloudR = baseR * 1.3;
        const outerStar = cloudR / 3;
        const midStar   = outerStar * 0.7;
        const innerStar = outerStar * 0.5;

        drawStar6(o.x, o.y, outerStar, midStar, "#f44336", 0.6);
        drawStar6(o.x, o.y, midStar,   innerStar, "#ff9800", 0.8);
        drawStar6(o.x, o.y, innerStar, innerStar * 0.6, "#fff176", 0.95);
      }
    }

    // --- Smoke for engine damage ---
    function drawSmokePuff(cx, cy, baseR, alpha, shade) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = shade;

      ctx.beginPath();
      ctx.arc(cx - baseR * 0.4, cy, baseR * 0.9, 0, Math.PI * 2);
      ctx.arc(cx + baseR * 0.2, cy - baseR * 0.3, baseR * 0.75, 0, Math.PI * 2);
      ctx.arc(cx + baseR * 0.5, cy + baseR * 0.1, baseR * 0.6, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawPlane() {
      const { x, y, width, height } = plane;
      const cx = x + width * 0.5;
      const cy = y + height * 0.5;

      let img, loaded, scale;

      if (planeType === "diego") {
        img = diegoImg;
        loaded = diegoLoaded;
        scale = 0.45;
      } else if (planeType === "dr1") {
        img = dr1Img;
        loaded = dr1Loaded;
        scale = 0.25;
      } else {
        img = dr3Img;
        loaded = dr3Loaded;
        scale = 0.45;
      }

      if (!loaded) {
        ctx.fillStyle = "red";
        fillRoundedRect(x, y, width, height, 4);
        return;
      }

      const imgWidth = img.width * scale;
      const imgHeight = img.height * scale;

      ctx.drawImage(
        img,
        cx - imgWidth / 2,
        cy - imgHeight / 2,
        imgWidth,
        imgHeight
      );

      const noseX = cx + imgWidth * 0.35;
      const noseY = cy;

      if (damageLevel >= 1 && damageLevel < 3) {
        const R = imgWidth * 0.09;

        drawSmokePuff(
          noseX - 4,
          noseY - 6,
          R,
          0.8,
          "rgb(90,90,90)"
        );

        drawSmokePuff(
          noseX - 14,
          noseY - 10,
          R * 1.5,
          0.6,
          "rgb(120,120,120)"
        );

        drawSmokePuff(
          noseX - 28,
          noseY - 14,
          R * 2.0,
          0.4,
          "rgb(150,150,150)"
        );
      }

      if (damageLevel >= 2 && damageLevel < 3) {
        ctx.beginPath();
        ctx.moveTo(noseX + 2, noseY - 4);
        ctx.quadraticCurveTo(noseX + 14, noseY - 22, noseX + 4, noseY - 10);
        ctx.quadraticCurveTo(noseX - 2, noseY - 16, noseX + 2, noseY - 4);
        ctx.fillStyle = "rgba(255,160,0,0.9)";
        ctx.fill();
      }

      if (damageLevel >= 3) {
        ctx.save();
        ctx.globalAlpha = 0.9;
        const explodeR = imgWidth * 0.6;
        const grad = ctx.createRadialGradient(
          cx, cy, explodeR * 0.2,
          cx, cy, explodeR
        );
        grad.addColorStop(0, "rgba(255,255,255,1)");
        grad.addColorStop(0.3, "rgba(255,200,0,1)");
        grad.addColorStop(0.7, "rgba(255,80,0,0.9)");
        grad.addColorStop(1, "rgba(80,20,0,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, cy, explodeR, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // --- Fog overlay (on top, including plane) ---
    function drawFogOverlay() {
      if (score < 100) return;

      const extra = Math.min((score - 100) * 0.003, 0.25);
      const alphaBottom = 0.30 + extra;
      const alphaTop = alphaBottom * 0.8;

      ctx.save();
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, `rgba(255,255,255, ${alphaTop.toFixed(3)})`);
      grad.addColorStop(1, `rgba(255,255,255, ${alphaBottom.toFixed(3)})`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
      ctx.restore();
    }

    function drawScene() {
      drawBackground();

      for (const o of obstacles) {
        drawObstacle(o);
      }
      drawPlane();

      drawFogOverlay();

      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(0, H / 2 - 70, W, 140);

        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";

        ctx.font = "30px " + UI_FONT;
        ctx.fillText("Game Over", W / 2, H / 2 - 20);

        ctx.font = "17px " + UI_FONT;
        ctx.fillText(`Score: ${score}  •  Best: ${bestScore}`, W / 2, H / 2 + 6);
        ctx.fillText("Tap or press SPACE to return to menu", W / 2, H / 2 + 34);
      }
    }

    // --- Splash: choose side ---
    function drawSplash() {
      if (screen !== "splash") return;

      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = "center";

      ctx.fillStyle = "#1e3a5f";
      ctx.font = "26px " + UI_FONT;
      ctx.fillText("WW1 Air Patrol", W / 2, H * 0.15);

      ctx.fillStyle = "#555";
      ctx.font = "16px " + UI_FONT;
      ctx.fillText("powered by", W / 2, H * 0.20);

      if (splashLogoLoaded) {
        const targetWidth = 160;
        const scale = Math.min(targetWidth / splashLogo.width, 1);
        const imgW = splashLogo.width * scale;
        const imgH = splashLogo.height * scale;
        const x = (W - imgW) / 2;
        const y = H * 0.22;
        ctx.drawImage(splashLogo, x, y, imgW, imgH);
      }

      ctx.fillStyle = "#333";
      ctx.font = "18px " + UI_FONT;
      ctx.fillText("Choose your side", W / 2, H * 0.45);

      const iconSize = 90;
      const iconY = H * 0.60;
      const germanX = W * 0.28;
      const britishX = W * 0.72;

      // German cross
      germanEntryRect = {
        x: germanX - iconSize / 2,
        y: iconY - iconSize / 2,
        w: iconSize,
        h: iconSize
      };
      ctx.save();
      ctx.translate(germanX, iconY);
      const s = iconSize / 2;
      ctx.fillStyle = "#000";
      ctx.fillRect(-s * 0.2, -s, s * 0.4, s * 2);
      ctx.fillRect(-s, -s * 0.2, s * 2, s * 0.4);
      ctx.fillStyle = "#fff";
      ctx.fillRect(-s * 0.12, -s * 0.75, s * 0.24, s * 1.5);
      ctx.fillRect(-s * 0.75, -s * 0.12, s * 1.5, s * 0.24);
      ctx.restore();

      // British roundel
      britishEntryRect = {
        x: britishX - iconSize / 2,
        y: iconY - iconSize / 2,
        w: iconSize,
        h: iconSize
      };
      ctx.save();
      ctx.translate(britishX, iconY);
      const r = iconSize * 0.45;
      ctx.beginPath();
      ctx.fillStyle = "#165ba5";
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = "#ffffff";
      ctx.arc(0, 0, r * 0.7, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = "#c7232c";
      ctx.arc(0, 0, r * 0.38, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.fillStyle = "#222";
      ctx.font = "15px " + UI_FONT;
      ctx.fillText("German Air Service", germanX, iconY + iconSize * 0.75);
      ctx.fillText("Royal Flying Corps", britishX, iconY + iconSize * 0.75);

      hintEl.textContent = "Tap a side to enter";
    }

    // --- German plane selection screen ---
    function drawGermanPlaneList() {
      if (screen !== "planeSelectGerman") return;

      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = "#f5f5f5";
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = "center";
      ctx.fillStyle = "#1e3a5f";
      ctx.font = "22px " + UI_FONT;
      ctx.fillText("German Air Service", W / 2, H * 0.12);

      ctx.fillStyle = "#555";
      ctx.font = "16px " + UI_FONT;
      ctx.fillText("Select your aircraft", W / 2, H * 0.18);

      hintEl.textContent = "Tap a tier to choose your aircraft";

      germanPlaneChoices = [];

      const startY = H * 0.26;
      const rowH = 90;
      const rowX = 40;
      const rowW = W - 80;

      const entries = [
        {
          tier: "Tier 1",
          label: "Fokker DR.3",
          planeType: "dr3",
          unlocked: true,
          img: dr3Img,
          loaded: dr3Loaded
        },
        {
          tier: "Tier 2",
          label: "Fokker DR.1",
          planeType: "dr1",
          unlocked: dr1Unlocked,
          img: dr1Img,
          loaded: dr1Loaded
        },
        {
          tier: "Tier 3",
          label: "DiegoPilot",
          planeType: "diego",
          unlocked: true,
          img: diegoImg,
          loaded: diegoLoaded
        }
      ];

      entries.forEach((entry, i) => {
        const y = startY + i * rowH;

        ctx.save();
        ctx.fillStyle = entry.unlocked ? "rgba(255,255,255,0.95)" : "rgba(220,220,220,0.9)";
        fillRoundedRect(rowX, y, rowW, rowH - 18, 12);

        ctx.strokeStyle = entry.unlocked ? "rgba(0,0,0,0.25)" : "rgba(0,0,0,0.15)";
        ctx.lineWidth = 1;
        ctx.strokeRect(rowX + 0.5, y + 0.5, rowW - 1, rowH - 19);

        const thumbX = rowX + 20;
        const thumbY = y + (rowH - 18) / 2;

        if (entry.loaded) {
          const maxW = 90;
          const scale = Math.min(maxW / entry.img.width, 0.5);
          const imgW = entry.img.width * scale;
          const imgH = entry.img.height * scale;
          ctx.drawImage(entry.img, thumbX - imgW / 2, thumbY - imgH / 2, imgW, imgH);
        } else {
          ctx.fillStyle = "#ccc";
          ctx.fillRect(thumbX - 30, thumbY - 15, 60, 30);
        }

        ctx.textAlign = "left";
        ctx.fillStyle = "#222";
        ctx.font = "14px " + UI_FONT;
        ctx.fillText(`${entry.tier} – ${entry.label}`, rowX + 80, y + 30);

        ctx.fillStyle = entry.unlocked ? "#4caf50" : "#999";
        ctx.font = "13px " + UI_FONT;
        ctx.fillText(entry.unlocked ? "Ready" : "Locked", rowX + 80, y + 52);

        ctx.restore();

        germanPlaneChoices.push({
          x: rowX,
          y,
          w: rowW,
          h: rowH - 18,
          planeType: entry.planeType,
          unlocked: entry.unlocked,
          tier: entry.tier
        });
      });

      ctx.textAlign = "center";
      ctx.fillStyle = "#777";
      ctx.font = "13px " + UI_FONT;
      ctx.fillText("Tap anywhere outside rows to go back", W / 2, H - 30);
    }

    // --- British: under construction ---
    function drawBritishWIP() {
      if (screen !== "planeSelectBritish") return;

      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = "#f5f5f5";
      ctx.fillRect(0, 0, W, H);

      ctx.textAlign = "center";

      ctx.fillStyle = "#1e3a5f";
      ctx.font = "22px " + UI_FONT;
      ctx.fillText("Royal Flying Corps", W / 2, H * 0.16);

      const centerX = W / 2;
      const centerY = H * 0.40;
      const r = 90;

      ctx.beginPath();
      ctx.fillStyle = "#165ba5";
      ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = "#ffffff";
      ctx.arc(centerX, centerY, r * 0.7, 0, Math.PI * 2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = "#c7232c";
      ctx.arc(centerX, centerY, r * 0.4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#555";
      ctx.font = "18px " + UI_FONT;
      ctx.fillText("Under construction", W / 2, H * 0.62);

      ctx.fillStyle = "#777";
      ctx.font = "14px " + UI_FONT;
      ctx.fillText("Tap to return to side selection", W / 2, H * 0.68);

      hintEl.textContent = "British side\nUnder construction – tap to go back";
    }

    function endGame() {
      gameOver = true;
      gameRunning = false;
      drawScene();
    }

    function loop(timestamp) {
      if (!gameRunning) return;

      if (!lastTime) {
        lastTime = timestamp;
        lastSpawnTime = timestamp;
      }
      const dt = timestamp - lastTime;
      lastTime = timestamp;

      update(dt, timestamp);
      drawScene();

      if (gameRunning) requestAnimationFrame(loop);
    }

    // --- Input helpers ---
    function getCanvasCoordinates(evt) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;

      if (evt.touches && evt.touches.length > 0) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else if (evt.changedTouches && evt.changedTouches.length > 0) {
        clientX = evt.changedTouches[0].clientX;
        clientY = evt.changedTouches[0].clientY;
      } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
      }

      const x = ((clientX - rect.left) / rect.width) * W;
      const y = ((clientY - rect.top) / rect.height) * H;
      return { x, y };
    }

    function handleInput(evt) {
      // --- MAIN MENU: side selection ---
      if (screen === "splash") {
        if (evt) {
          const { x, y } = getCanvasCoordinates(evt);

          function inside(r) {
            return r && x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h;
          }

          if (inside(germanEntryRect)) {
            screen = "planeSelectGerman";
            drawGermanPlaneList();
            return;
          }
          if (inside(britishEntryRect)) {
            screen = "planeSelectBritish";
            drawBritishWIP();
            return;
          }
          return;
        } else {
          // keyboard: start German Tier 1 by default
          planeType = "dr3";
          screen = "game";
          hintEl.textContent = "Tap or press SPACE to fly ✈️";
          resetGame();
          flap();
          startGameLoop();
          return;
        }
      }

      // --- GERMAN PLANE SELECT ---
      if (screen === "planeSelectGerman") {
        if (!evt) {
          // keyboard default: Tier 1
          planeType = "dr3";
          screen = "game";
          hintEl.textContent = "Tap or press SPACE to fly ✈️";
          resetGame();
          flap();
          startGameLoop();
          return;
        }

        const { x, y } = getCanvasCoordinates(evt);
        let clickedRow = null;
        for (const row of germanPlaneChoices) {
          if (x >= row.x && x <= row.x + row.w && y >= row.y && y <= row.y + row.h) {
            clickedRow = row;
            break;
          }
        }

        if (clickedRow) {
          if (!clickedRow.unlocked) {
            hintEl.textContent = "Tier 2 locked.\nReach Stage 4 with 40+ points to unlock.";
            return;
          }
          planeType = clickedRow.planeType;
          screen = "game";
          hintEl.textContent = "Tap or press SPACE to fly ✈️";
          resetGame();
          flap();
          startGameLoop();
          return;
        } else {
          // tapped outside rows → back to splash
          screen = "splash";
          hintEl.textContent = "Tap a side to enter";
          drawSplash();
          return;
        }
      }

      // --- BRITISH: UNDER CONSTRUCTION ---
      if (screen === "planeSelectBritish") {
        // any input -> back to splash
        screen = "splash";
        hintEl.textContent = "Tap a side to enter";
        drawSplash();
        return;
      }

      // --- GAME OVER: return to menu ---
      if (gameOver) {
        gameOver = false;
        screen = "splash";
        hintEl.textContent = "Tap a side to enter";
        drawSplash();
        return;
      }

      // --- IN-GAME: flap/start ---
      if (screen === "game") {
        flap();
        startGameLoop();
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space" || e.code === "ArrowUp") {
        e.preventDefault();
        handleInput(null);
      }
    });

    window.addEventListener("mousedown", (e) => {
      e.preventDefault();
      handleInput(e);
    });

    window.addEventListener("touchstart", (e) => {
      e.preventDefault();
      handleInput(e);
    }, { passive: false });

    // --- Initial state ---
    resetGame();
    drawSplash();
  </script>
</body>
</html>